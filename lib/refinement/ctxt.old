open Core
open Reporting

module Global = struct
  type t =
    { oracle : Oracle.t
    ; ty_param_source : int
    }
  [@@deriving create, show]

  let fresh_generic ({ ty_param_source; _ } as t) =
    let nm = Format.sprintf {|T#%n|} ty_param_source in
    let ty_param_source = ty_param_source + 1 in
    { t with ty_param_source }, Name.Ty_param.of_string nm
  ;;

  let fresh_generics ({ ty_param_source; _ } as t) n =
    let ty_param_source = ty_param_source + n in
    let ty_params = List.init n ~f:(fun i -> Name.Ty_param.of_string @@ Format.sprintf {|T#%n|} (i + n)) in
    { t with ty_param_source }, ty_params
  ;;

  let up { oracle; _ } ~of_ ~at = Oracle.up oracle ~of_ ~at
  let down { oracle; _ } ~of_ ~at = Oracle.down oracle ~of_ ~at
  let param_variances_opt { oracle; _ } ~ctor = Oracle.param_variances_opt oracle ~ctor
end

module Cont = struct
  module Rfmnt = struct
    type t =
      { this_ : Ty.Param_bounds.t option
      ; ty_param : Ty.Param.Refinement.t
      }
    [@@deriving create, show]

    let param_rfmnt { ty_param; _ } nm = Ty.Param.Refinement.find ty_param nm
  end

  type t =
    { ty_param : Ty.Param.Ctxt.t
    ; is_rfmnt : Rfmnt.t
    ; as_rfmnt : Rfmnt.t
    }
  [@@deriving create, show]

  let param_bounds { ty_param; as_rfmnt; is_rfmnt } nm =
    Option.map ~f:(fun param_bounds ->
      let open Ty.Param.Refinement in
      match Rfmnt.(param_rfmnt as_rfmnt nm, param_rfmnt is_rfmnt nm) with
      | Bounds_top, Bounds_top -> param_bounds
      | Bounds_top, Bounds rfmt_bounds | Bounds rfmt_bounds, Bounds_top ->
        Ty.Param_bounds.meet param_bounds rfmt_bounds ~prov:Prov.empty
      | Bounds as_bounds, Bounds is_bounds ->
        Ty.Param_bounds.(meet (meet param_bounds as_bounds ~prov:Prov.empty) is_bounds ~prov:Prov.empty)
      | Bounds_bottom, _ | _, Bounds_bottom -> Ty.Param_bounds.bottom Prov.empty)
    @@ Ty.Param.Ctxt.find ty_param nm
  ;;

  let bind_param ty_param Ty.Param.{ name = Located.{ elem; _ }; param_bounds } =
    Ty.Param.Ctxt.bind ty_param elem param_bounds
  ;;

  let bind_all ({ ty_param; _ } as t) ty_params =
    let ty_param = List.fold_left ty_params ~init:ty_param ~f:bind_param in
    { t with ty_param }
  ;;
end

(* type t =
  { ty_param : Ty.Param.Ctxt.t
  ; ty_param_refine : Ty.Param.Refinement.t
  ; oracle : Oracle.t
  ; ty_param_source : int
  }
[@@deriving create, show] *)

(* let create = create ~ty_param_source:0

let fresh_generics ({ ty_param_source; _ } as t) n =
  let ty_param_source = ty_param_source + n in
  ( { t with ty_param_source }
  , List.init n ~f:(fun n -> Name.Ty_param.of_string @@ Format.sprintf "T#%n" (ty_param_source + n)) )
;; *)

(* let param_bounds { ty_param; ty_param_refine; _ } id =
  Option.map ~f:(fun bounds ->
    match Ty.Param.Refinement.find ty_param_refine id with
    | Ty.Param.Refinement.Bounds_top -> bounds
    | Ty.Param.Refinement.Bounds_bottom -> Ty.Param_bounds.bottom Reporting.Prov.empty
    | Ty.Param.Refinement.Bounds other -> Ty.Param_bounds.meet bounds other ~prov:Reporting.Prov.empty)
  @@ Ty.Param.Ctxt.find ty_param id
;; *)
