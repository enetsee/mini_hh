open Core

module Fn = struct
  type t = { ret_ty : Ty.t } [@@deriving create, show]
end

module Formula = struct
  type t =
    | Atom of Ty.t
    | Inter of t * t
    | Union of t * t
    | Top
    | Bottom
  [@@deriving compare, eq, sexp, show, variants]
end

module Local = struct
  (** A local environment is a map from term variables names to *)
  type t = Ty.t Name.Tm_var.Map.t [@@deriving compare, eq, sexp, show]

  let empty = Name.Tm_var.Map.empty
  let bottom = empty
  let find t local = Map.find t local
  let is_bound t local = Option.is_some @@ find t local

  let join t1 t2 ~prov =
    let f ~key:_ = function
      | `Left ty | `Right ty -> Some ty
      | `Both (ty1, ty2) -> Some (Ty.union ~prov [ ty1; ty2 ])
    in
    Map.merge t1 t2 ~f
  ;;

  let meet t1 t2 ~prov =
    let f ~key:_ = function
      | `Left _ | `Right _ -> None
      | `Both (ty1, ty2) -> Some (Ty.inter ~prov [ ty1; ty2 ])
    in
    Map.merge t1 t2 ~f
  ;;

  let merge_right t1 t2 : t =
    let f ~key:_ = function
      | `Left v | `Right v | `Both (_, v) -> Some v
    in
    Map.merge t1 t2 ~f
  ;;

  let merge_disjoint_exn t1 t2 = Map.merge_disjoint_exn t1 t2
  let bind_local t local ty = Map.update t local ~f:(fun _ -> ty)
  let map t ~f = Name.Tm_var.Map.map t ~f

  let symm_diff (t1 : t) (t2 : t) =
    let k1 = Map.key_set t1
    and k2 = Map.key_set t2 in
    Set.symmetric_diff k1 k2
  ;;

  module Refinement = struct
    (** A local refinement is a map from term variables names to formula over types*)
    type t = Formula.t Name.Tm_var.Map.t [@@deriving compare, eq, sexp, show]

    let empty = Name.Tm_var.Map.empty
  end
end

(* module Ty_refine = struct
  module Refine_key = struct
    (** A type refinement key is either a term variable or a member property
        TODO(mjt) Add members *)
    type t = Local of Name.Tm_var.t [@@deriving compare, eq, sexp, show]
  end

  module Refine_map = struct
    include Map.Make (Refine_key)

    let pp pp_a ppf t = Fmt.(vbox @@ list ~sep:cut @@ pair ~sep:(any " => ") Refine_key.pp pp_a) ppf @@ Map.to_alist t
  end

  type t = Ty.Refinement.t Refine_map.t [@@deriving compare, eq, sexp, show]

  let empty = Refine_map.empty
  let find_local t local = Map.find t (Refine_key.Local local)

  let join t1 t2 =
    let f ~key:_ = function
      | `Left rfn | `Right rfn -> Some rfn
      | `Both (rfn1, rfn2) -> Some (Ty.Refinement.join rfn1 rfn2)
    in
    Map.merge t1 t2 ~f
  ;;

  let meet t1 t2 =
    let f ~key:_ = function
      | `Left _ | `Right _ -> None
      | `Both (rfn1, rfn2) -> Some (Ty.Refinement.meet rfn1 rfn2)
    in
    Map.merge t1 t2 ~f
  ;;

  let cmp t = Refine_map.map t ~f:Ty.Refinement.cmp
  let of_local local ty : t = Refine_map.singleton Refine_key.(Local local) @@ Ty.Refinement.pos ty
end *)

module Cont = struct
  module Rfmnt = struct
    type t =
      { local : Local.Refinement.t
      ; this_ : Ty.Param_bounds.t option
      ; ty_param : Ty.Param.Refinement.t
      }
    [@@deriving create, show]

    let empty = { this_ = None; local = Local.Refinement.empty; ty_param = Ty.Param.Refinement.empty }
  end

  type t =
    { local : Local.t
    ; ty_param : Ty.Param.Ctxt.t
    ; is_rfmnt : Rfmnt.t
    ; as_rfmnt : Rfmnt.t
    }
  [@@deriving create, show]

  let empty = { local = Local.empty; ty_param = Ty.Param.Ctxt.empty; is_rfmnt = Rfmnt.empty; as_rfmnt = Rfmnt.empty }
end

module Global = struct
  type t =
    { oracle : Oracle.t (** Global source of information about inheritence and implementation *)
    ; errs : Err.t list (** Accumulated errors & warnings *)
    ; this : Ty.Param_bounds.t option (** The bounds which apply to [$this], if any *)
    ; fn : Fn.t option (** The function context, if any *)
    ; ty_param_source : int (** Source of fresh names for type params *)
    }
  [@@deriving create, show]
end

let find_local Cont.{ local; _ } tm_var =
  (* TODO(mjt) apply refinements *)
  Local.find local tm_var
;;

let refine ~ty_scrut ~ty_test ~glbl ~cont:_ =
  let refinement_glbl =
    let Global.{ oracle; ty_param_source; _ } = glbl in
    Refinement.Ctxt.Global.create ~oracle ~ty_param_source ()
  and refinement_cont = failwith "" in
  Refinement.refine ~ty_scrut ~ty_test ~cont:refinement_cont ~glbl:refinement_glbl
;;

let tell_is_subtype ~ty_sub ~ty_super ~glbl ~cont:_ =
  (* let subtyping_ctxt = Subtyping.Ctxt.create ~oracle ~ty_param ~ty_param_refine () in *)
  let subtyping_glbl =
    let Global.{ oracle; ty_param_source; _ } = glbl in
    Subtyping.Ctxt.Global.create ~oracle ~ty_param_source ()
  and subtyping_cont = failwith "" in
  match Subtyping.Tell.is_subtype ~ty_sub ~ty_super ~cont:subtyping_cont ~glbl:subtyping_glbl with
  | Error err -> Global.{ glbl with errs = Err.subtyping err :: glbl.errs }
  | Ok _ -> glbl
;;

(* let refine _ _ ~ty_scut ~ty_test =
   match Refinement.refine ~ty_scrut ~ty_test *)
